"""Authentication token model for centralized token management."""

import hashlib
import secrets
from datetime import datetime, timezone
from enum import Enum
from typing import Optional

from sqlalchemy import JSON, Column, DateTime
from sqlalchemy import Enum as SQLEnum
from sqlalchemy import ForeignKey, Index, String, text
from sqlalchemy.dialects.postgresql import JSONB
# from sqlalchemy.orm import relationship  # Commented out - not used
from sqlalchemy.sql import sqltypes

from .base import BaseModel
from .types import UUID


class JSONBType(sqltypes.TypeDecorator):
    """A type that uses JSONB for PostgreSQL and JSON for other databases."""

    impl = JSON
    cache_ok = True

    def load_dialect_impl(self, dialect):
        if dialect.name == "postgresql":
            return dialect.type_descriptor(JSONB())
        else:
            return dialect.type_descriptor(JSON())


class TokenType(str, Enum):
    """Token types supported by the system."""

    ACCESS = "access"
    REFRESH = "refresh"
    RESET_PASSWORD = "reset_password"
    EMAIL_VERIFICATION = "email_verification"
    API_KEY = "api_key"


class TokenStatus(str, Enum):
    """Token status values."""

    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"
    USED = "used"


class AuthToken(BaseModel):
    """Authentication token model for secure token management.

    This model supports:
    - Short-lived access tokens and long-lived refresh tokens
    - Token rotation and revocation tracking
    - Comprehensive audit trails
    - Encrypted storage of sensitive data
    - HIPAA-compliant logging
    """

    __tablename__ = "auth_tokens"

    # Token identification (encrypted hash, never store plaintext)
    token_hash = Column(String(128), nullable=False, unique=True, index=True)

    # Token metadata
    token_type: Column[str] = Column(SQLEnum(TokenType), nullable=False, index=True)
    status: Column[str] = Column(
        SQLEnum(
            TokenStatus, 
            values_callable=lambda obj: [e.value for e in obj]
        ),
        default=TokenStatus.ACTIVE,
        nullable=False,
        index=True,
    )

    # User association (nullable for system tokens)
    user_id: Column[UUID] = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
    )

    # Relationship to User (commented out due to disabled User model)
    # user = relationship("User", back_populates="auth_tokens")

    # Token lifecycle
    issued_at = Column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    )
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    last_used_at = Column(DateTime(timezone=True), nullable=True)
    revoked_at = Column(DateTime(timezone=True), nullable=True)

    # Token metadata and scopes
    issuer = Column(String(255), nullable=False, default="pms-backend")
    audience = Column(String(255), nullable=False, default="pms-client")
    scopes = Column(JSONBType, nullable=True)  # List of permission scopes

    # Client information (anonymized for HIPAA)
    client_ip_hash = Column(String(128), nullable=True)
    user_agent_hash = Column(String(128), nullable=True)

    # Rotation tracking
    parent_token_id: Column[UUID] = Column(
        UUID(as_uuid=True),
        ForeignKey("auth_tokens.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
    )
    rotation_count = Column(String(10), default="0", nullable=False)

    # Additional metadata
    token_metadata = Column(JSONBType, nullable=True)

    # Performance indexes
    __table_args__ = (
        Index("idx_auth_tokens_user_type", "user_id", "token_type"),
        Index("idx_auth_tokens_status_expires", "status", "expires_at"),
        Index("idx_auth_tokens_hash", "token_hash"),
        Index("idx_auth_tokens_parent", "parent_token_id"),
        Index("idx_auth_tokens_correlation", "correlation_id"),
        Index(
            "idx_auth_tokens_cleanup", 
            "status", 
            "expires_at", 
            "created_at"
        ),
    )

    @classmethod
    def hash_token(cls, token: str) -> str:
        """Create a secure hash of the token for storage.

        Args:
            token: The plaintext token to hash

        Returns:
            SHA-256 hash of the token
        """
        return hashlib.sha256(token.encode()).hexdigest()

    @classmethod
    def hash_client_info(cls, info: str) -> Optional[str]:
        """Hash client information for privacy-compliant storage.

        Args:
            info: Client information (IP, user agent, etc.)

        Returns:
            SHA-256 hash of the information
        """
        if not info:
            return None
        return hashlib.sha256(info.encode()).hexdigest()

    @classmethod
    def generate_token(cls, length: int = 32) -> str:
        """Generate a cryptographically secure random token.

        Args:
            length: Length of the token in bytes

        Returns:
            URL-safe base64 encoded token
        """
        return secrets.token_urlsafe(length)

    def is_expired(self) -> bool:
        """Check if the token is expired.

        Returns:
            True if the token is expired
        """
        now = datetime.now(timezone.utc)
        expires_at = self.expires_at

        # Handle timezone-naive datetimes from SQLite
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)

        return bool(now > expires_at)

    def is_active(self) -> bool:
        """Check if the token is active and usable.

        Returns:
            True if the token is active and not expired
        """
        return bool(
            self.status == TokenStatus.ACTIVE.value and not self.is_expired()
        )

    def revoke(self, reason: Optional[str] = None) -> None:
        """Revoke the token.

        Args:
            reason: Optional reason for revocation
        """
        from sqlalchemy.orm import object_session

        session = object_session(self)
        if session:
            session.execute(
                text(
                    f"UPDATE {self.__tablename__} SET status = :status, "
                    f"revoked_at = :revoked_at WHERE id = :id"
                ),
                {
                    "status": TokenStatus.REVOKED.value,
                    "revoked_at": datetime.now(timezone.utc),
                    "id": str(self.id),
                },
            )

    def mark_used(self) -> None:
        """Mark the token as used (for one-time tokens)."""
        from sqlalchemy.orm import object_session

        session = object_session(self)
        if session:
            now = datetime.now(timezone.utc)
            updates = {"last_used_at": now}

            # Mark one-time tokens as used
            if self.token_type in [
                TokenType.RESET_PASSWORD,
                TokenType.EMAIL_VERIFICATION,
            ]:
                updates["status"] = TokenStatus.USED.value

            session.execute(
                text(
                    f"UPDATE {self.__tablename__} SET "
                    + ", ".join([f"{k} = :{k}" for k in updates.keys()])
                    + " WHERE id = :id"
                ),
                {**updates, "id": str(self.id)},
            )

    def get_ttl_seconds(self) -> int:
        """Get time-to-live in seconds.

        Returns:
            Seconds until expiration, 0 if expired
        """
        if self.is_expired():
            return 0

        now = datetime.now(timezone.utc)
        expires_at = self.expires_at

        # Handle timezone-naive datetimes from SQLite
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)

        delta = expires_at - now
        return max(0, int(delta.total_seconds()))

    def to_dict(self) -> dict:
        """Convert to dictionary, excluding sensitive fields.

        Returns:
            Dictionary representation without sensitive data
        """
        return {
            "id": self.id,
            "token_type": self.token_type.value,
            "status": self.status.value,
            "user_id": str(self.user_id) if self.user_id else None,
            "issued_at": self.issued_at.isoformat(),
            "expires_at": self.expires_at.isoformat(),
            "last_used_at": (
                self.last_used_at.isoformat() if self.last_used_at else None
            ),
            "issuer": self.issuer,
            "audience": self.audience,
            "scopes": self.scopes,
            "rotation_count": self.rotation_count,
            "is_active": self.is_active(),
            "ttl_seconds": self.get_ttl_seconds(),
        }

    def __repr__(self) -> str:
        """String representation without sensitive data."""
        return (
            f"<AuthToken(id={self.id}, "
            f"type={self.token_type.value}, "
            f"status={self.status.value}, "
            f"expires={self.expires_at.isoformat()})>"
        )